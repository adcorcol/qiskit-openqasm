\documentclass[USenglish,12pt,fleqn]{article} % Set [final] to switch off todonotes, Set [draft] for faster minted processing
\usepackage[USenglish=usenglishmax]{hyphsubst}
\usepackage{babel}
\usepackage{ragged2e}
\usepackage{amsmath,amssymb,amsfonts}
\let\equation\gather \let\endequation\endgather
\usepackage{verbatim}
\usepackage[final]{graphicx}

\usepackage[epsilon,tstt]{backnaur}

\usepackage[fixpdftex,xcdraw]{xcolor}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage[numbers,sort&compress]{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{array,booktabs,threeparttable}
\newcolumntype{L}[1]{>{\RaggedRight\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{C}[1]{>{\Centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{\RaggedLeft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\usepackage[margin=20pt,font=small,labelfont=bf]{caption}
\usepackage[marginal]{footmisc}
\usepackage{pdflscape}
\usepackage{rotating}
\usepackage{tikz}
\usepackage[colorlinks=true]{hyperref}
\usepackage{url}
\usepackage{minted}
\newmintedfile{c}{}

\providecommand{\ket}[1]{\left|#1 \right\rangle}
\usetikzlibrary{decorations.pathreplacing,decorations.pathmorphing}

\newenvironment{bnfsplit}[1][0.7\textwidth]
 {\minipage[t]{#1}$}
 {$\endminipage}

\newcommand{\fname}[1]{\texttt{#1}}

\newcommand*{\object}{\textbf}
\newcommand*{\code}{\texttt}
\begin{document}

\title{Open Quantum Assembly Language}
\author{Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta}
\date{January 10th, 2017}

\maketitle

\section{Background}

Software architectures, compilers, and languages specifically for quantum computing have been studied by the academic community for more than a decade (\cite{selinger04,gay06,svore06,haner16} and references therein). Researchers have implemented software and simulators that can be used in practice to study quantum algorithms at many scales. While we cannot survey this work here, we list a few of these projects, several of which include software that has been made readily available: Liquid \cite{ws14,liquid}, Scaffold \cite{scaffold,scaffcc}, Quipper \cite{valiron15,quipper,green13}, ProjectQ \cite{steiger16,projectq}, QCL \cite{omer03,qcl}, Quiddpro \cite{quiddpro,viamontes05}, Chisel-q \cite{chiselq,chisel}, and Quil \cite{Quil,smith16}.

Our goal in this document is to describe an interface language for the Quantum Experience that enables experiments with small depth quantum circuits. The language can be generated by the Composer, hand-written, or targeted by higher level software tools, such as those above. Before we do so, we discuss quantum programs in general to provide context. General quantum programs require coordination of quantum and classical parts of the computation. One way to think about general quantum programs is to identify their distinct phases of execution \cite{green13}. Fig.~\ref{fig:diagram} shows a high-level diagram of the processes and abstractions involved in specifying a quantum algorithm, transforming the algorithm into executable form, running an experiment or simulation, and analyzing the results. A key idea throughout these processes is the use of intermediate representations. An intermediate representation (IR) of a computation is neither its source language description, nor the target machine instructions, but something in between. Compilers may use several IRs during the process of translating and optimizing a program.

{\bf Compilation.} This phase takes place on a classical computer in a setting where specific problem parameters are not yet known and no interaction with the quantum computer is required, i.e. it is offline. The input is source code describing a quantum algorithm and any compile time parameters. The output is a combined quantum/classical program expressed using a high level IR. During this phase, it is possible to compile classical procedures into object code and make initial passes that do not require complete knowledge of the problem parameters.

{\bf Circuit generation.} This takes place on a classical computer in an environment where specific problem parameters are now known, and some interaction with the quantum computer may occur, i.e. this is an online phase. The input is a quantum/classical program expressed using a high level IR, as well as all remaining problem parameters. The output is a collection of quantum circuits, or quantum basic blocks, together with associated classical control instructions and classical object code needed at run-time. A basic block is a straight-line code sequence with no branches (except at the entry and exit points). Since feedback can occur on multiple time scales, the quantum circuits may include instructions for fast feedback. Other classical control instructions outside of the quantum circuit basic block include, for example, run-time parameter computations and measurement-dependent branches. External classical object code could include algorithms to process measurement outcomes into control flow conditions or results, or to generate new basic blocks on the fly. The output of circuit generation is expressed using a quantum circuit IR. Further circuit generation may occur based on processed measurement results.

{\bf Execution.} This takes place on physical quantum computer controllers in a real-time environment, i.e. the quantum computer is active. The input is a collection of quantum circuits and associated run-time control statements expressed using a quantum circuit IR. The input is processed by a high-level controller into a stream of real-time instructions in a low-level format that corresponds to physical operations. These are executed on a low-level controller, and a corresponding results stream provides measurement data back to the high-level controller when needed. In general, the high level controller (or virtual machine) can execute classical control instructions and external object code. The output of circuit execution is a collection of processed measurement results returned from the high-level controller.

{\bf Post-processing.} This takes place on a classical computer after all real-time processing is complete. The input is a collection of processed measurement results, and the output is intermediate results for further circuit generation and/or the final result of the quantum computation.

\begin{figure}[h]
\hspace{-0.2cm}
\includegraphics[width=17cm]{figs/blocks.pdf}
\caption{Block diagrams of processes (blue) and abstractions (red) to transform and execute a quantum algorithm. The emphasized quantum circuit abstraction is the main focus of this document. The API and Resource Manager (green) represents the gateway to backend processes for circuit execution. Dashed vertical lines separate offline, online, and real-time processes.
\label{fig:diagram}}
\end{figure}

Our model of program execution on the Quantum Experience does not allow fully general classical computations in the loop with quantum computations, as described above, because qubits remain coherent for a limited time. Quantum programs are broken into distinct circuits whose quantum outputs cannot be carried over into the next circuit. Classical computation is done between quantum circuit executions. Users actively participate in the circuit generation phase and manually implement part of feedback path through the high level controller in Fig.~\ref{fig:diagram}, observing outcomes from the previous quantum circuit and choosing the next quantum circuit to execute. Making use of an API to the execution phase, users can write their own software for compilation and circuit generation that interacts with the hardware over a sequence of quantum circuit executions. After obtaining all of the processed results, users may post-process the data offline.

We specify part of a quantum circuit intermediate representation based on the quantum circuit model, a standard formalism for quantum computation \cite{NC00}. The quantum circuit abstraction is emphasized in Fig.~\ref{fig:diagram}. The IR expresses quantum circuits with fast feedback, such as might constitute the basic blocks of a full-featured IR. A basic block is a straight-line code sequence with no branches (except at the entry and exit points). We have chosen to include statements that are essential for near-term experiments and that we believe will be present in any future IR. The representation will be quite familiar to experts.

The human-readable form of our quantum circuit IR is based on ``quantum assembly language'' \cite{qasm2circ,qasmtools,svore06,quale,dousti16} or QASM (pronounced {\it kazm}). QASM is a simple text language that describes generic quantum circuits. QASM can represent a completely “unrolled” quantum program whose parameters have all been specified. Most QASM variants assume a discrete set of quantum gates, but our IR is designed to control a physical system with a parameterized gate set. While we use the term ``quantum assembly language'', this is merely an analogy and should not be taken too far.

Open QASM represents universal physical circuits, so we propose a built-in gate basis of arbitrary single-qubit gates and a two-qubit entangling gate (CNOT) \cite{barenco95}. We choose a simple language without higher level programming primitives. We define different gate sets using a subroutine-like mechanism that hierarchically specifies new unitary gates in terms of built-in gates and previously defined gate subroutines. In this way, the built-in basis is used to define hardware-supported operations via standard header files. The subroutine mechanism allows limited code reuse by hierarchically defining more complex operations \cite{scaffold,dousti16}. We also add instructions that model a quantum-classical interface, specifically measurement, state reset, and the most elemental classical feedback.

The remaining sections of this document specify Open QASM and provide examples.

\section{Language}\label{sec:spec}

The syntax of the human-readable form of Open QASM has elements of C and assembly languages. The first (non-comment) line of an Open QASM program must be \code{OPENQASM M.m;} indicating a major version~M and minor version~m. Version 2.0 is described in this document. The version keyword cannot occur multiple times in a file. Statements are separated by semicolons. Whitespace is ignored. The language is case sensitive. Comments begin with a pair of forward slashes and end with a new line. The statement \code{include "filename";} continues parsing \code{filename} as if the contents of the file were pasted at the location of the \code{include} statement. The path is specified relative to the current working directory.

The only storage types of Open QASM (version 2.0) are classical and quantum registers, which are one-dimensional arrays of bits and qubits, respectively. The statement \code{qreg name[size];} declares an array of qubits (quantum register) with the given name and size. Identifiers, such as \code{name}, must start with a lowercase letter and can contain alpha-numeric characters and underscores. The label \code{name[j]} refers to a qubit of this register, where $j\in \{0,1,\dots,\mathrm{size}(\mathrm{name})-1\}$. The qubits are initialized to $|0\rangle$. Likewise, \code{creg name[size];} declares an array of bits (register) with the given name and size. The label \code{name[j]} refers to a bit of this register, where $j\in \{0,1,\dots,\mathrm{size}(\mathrm{name})-1\}$. The bits are initialized to $0$.

\begin{figure}
\begin{minipage}{.2\textwidth}
\include{qpics/cnotqq}
\end{minipage}
\begin{minipage}{.2\textwidth}
\include{qpics/cnotrr}
\end{minipage}
\begin{minipage}{.2\textwidth}
\include{qpics/cnotrq}
\end{minipage}
\begin{minipage}{.2\textwidth}
\include{qpics/cnotqr}
\end{minipage}
\caption{The built-in two-qubit entangling gate is the controlled-NOT gate. If \code{a} and \code{b} are qubits, the statement \code{CX a,b;} applies a controlled-NOT (CNOT) gate that flips the target qubit \code{b} iff the control qubit \code{a} is one. If \code{a} and \code{b} are quantum registers, the statement applies CNOT gates between corresponding qubits of each register. There is a similar meaning when \code{a} is a qubit and \code{b} is a quantum register and vice versa.
\label{fig:cnot}}
\end{figure}

\begin{figure}
\hspace{.2\textwidth}
\begin{minipage}{.2\textwidth}
\include{qpics/uq}
\end{minipage}
\hspace{.1\textwidth}
\begin{minipage}{.2\textwidth}
\include{qpics/ur}
\end{minipage}
\caption{The single-qubit unitary gates are built in. These gates are parameterized by three real parameters $\theta$, $\phi$, and $\lambda$. If the argument \code{q} is a quantum register, the statement applies \code{size(q)} gates in parallel to the qubits of the register.\label{fig:utpl}}
\end{figure}

The built-in universal gate basis is ``CNOT + $U(2)$''. There is one built-in two-qubit gate (Fig.~\ref{fig:cnot})
\begin{equation}
\mathrm{CNOT} := \left(\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \end{array}\right)
\end{equation}
called the controlled-NOT gate. The statement \code{CX a,b;} applies a CNOT gate that flips the target qubit \code{b} if and only if the control qubit \code{a} is one. The arguments cannot refer to the same qubit. Built-in gates have reserved uppercase keywords. If \code{a} and \code{b} are quantum registers {\em with the same size}, the statement means apply \code{CX a[j], b[j];} for each index \code{j} into register \code{a}. If instead, \code{a} is a qubit and \code{b} is a quantum register, the statement means apply \code{CX a, b[j];} for each index \code{j} into register \code{b}. Finally, if \code{a} is a quantum register and \code{b} is a qubit, the statement means apply \code{CX a[j], b;} for each index \code{j} into register \code{a}.

All of the single-qubit unitary gates are also built in (Fig.~\ref{fig:utpl}) and parameterized as
\begin{equation}
U(\theta,\phi,\lambda) := R_z(\phi)R_y(\theta)R_z(\lambda) = \left(\begin{array}{cc} e^{-i(\phi+\lambda)/2}\cos(\theta/2) & -e^{-i(\phi-\lambda)/2}\sin(\theta/2) \\
e^{i(\phi-\lambda)/2}\sin(\theta/2) & e^{i(\phi+\lambda)/2}\cos(\theta/2) \end{array}\right).
\end{equation}
Here $R_y(\theta)=\mathrm{exp}(-i\theta Y/2)$ and $R_z(\phi)=\mathrm{exp}(-i\theta Z/2)$. This specifies any element of $SU(2)$. When \code{a} is a quantum register, the statement \code{U(theta,phi,lambda) a;} means apply \code{U(theta,phi,lambda) a[j];} for each index \code{j} into register \code{a}. The real parameters $\theta\in [0,4\pi)$, $\phi\in [0,4\pi)$, and $\lambda\in [0,4\pi)$ are given by {\it parameter expressions} constructed using in-fix notation. These support scientific calculator features with arbitrary precision real numbers\footnote{Features include scientific notation; real arithmetic; logarithmic, trigonometic, and exponential functions; square roots; and the built-in constant $\pi$. The Quantum Experience uses a double precision floating point type for real numbers.}. For example, \code{U(pi/2,0,pi) q[0];} applies a Hadamard gate to qubit \code{q[0]}. Open QASM (version 2.0) does not provide a mechanism for computing parameters based on measurement outcomes.

New gates can be defined as unitary subroutines using the built-in gates, as shown in Fig.~\ref{fig:gate}. These can be viewed as macros whose expansion we defer until run-time. Gates are defined by statements of the form
\begin{minted}{c}
// comment
gate name(params) qargs 
{ 
  body 
}
\end{minted}
where the optional parameter list \code{params} is a comma-separated list of variable parameter names, and the argument list \code{qargs} is a comma-separated list of qubit arguments. Both the parameter names and qubit arguments are identifiers. If there are no variable parameters, the parentheses are optional. At least one qubit argument is required. The first comment may contain documentation, such as TeX markup, to be associated with the gate. The arguments in \code{qargs} cannot be indexed within the body of the gate definition. 
\begin{minted}{c}
// this is ok:
gate g a 
{ 
  U(0,0,0) a; 
}
// this is invalid:
gate g a 
{ 
  U(0,0,0) a[0]; 
}
\end{minted}
Only built-in gate statements, calls to previously defined gates, and barrier statements can appear in \code{body}. The statements in the body can only refer to the symbols given in the parameter or argument list, and these symbols are scoped only to the subroutine body. An empty body corresponds to the identity gate. Subroutines must be declared before use and cannot call themselves. The statement \code{name(params) qargs;} applies the subroutine, and the variable parameters \code{params} are given as parameter expressions. The gate can be applied to any combination of qubits and quantum registers {\em of the same size} as shown in the following example. The quantum circuit given by
\begin{minted}{c}
gate g qb0,qb1,qb2,qb3 
{ 
  // body 
}
qreg qr0[1];
qreg qr1[2];
qreg qr2[3];
qreg qr3[2];
g qr0[0],qr1,qr2[0],qr3; // ok
g qr0[0],qr2,qr1[0],qr3; // error!
\end{minted}
has a second-to-last line that means
\begin{algorithmic}[0]
 \For{$j \gets 0, 1$}
 \State \code{g qr0[0],qr1[j],qr2[0],qr3[j];}
 \EndFor
\end{algorithmic}
We provide this so that user-defined gates can be applied in parallel like the built-in gates.

\begin{figure}
\hspace{.1\textwidth}
\begin{minipage}{.4\textwidth}
\include{qpics/gate}
\end{minipage}

\hspace{.3\textwidth}
\begin{minipage}{.3\textwidth}
\begin{minted}{c}
gate cu1(lambda) a,b
{
  U(0,0,theta/2) a;
  CX a,b;
  U(0,0,-theta/2) b;
  CX a,b;
  U(0,0,theta/2) b;
}
cu1(pi/2) q[0],q[1];
\end{minted}
\end{minipage}

\caption{New gates are defined as unitary subroutines. The gates are applied using the statement \code{name(params) qargs;} just like the built-in gates. The parentheses are optional if there are no parameters. The gate $\mathrm{cu1}(\theta)$ corresponds to the unitary matrix $\mathrm{diag}(1,1,1,e^{i\theta})$ up to a global phase.
\label{fig:gate}}
\end{figure}

To support gates whose physical implementation may be possible, but whose definition is unspecified, we provide an ``opaque'' gate declaration. This may be used in practice in several instances. For example, the system may evolve under some fixed but uncharacterized drift Hamiltonian for some fixed amount of time. The system might be subject to an $n$-qubit operator whose parameters are computationally challenging to estimate. The syntax for an opaque gate declaration is the same as a gate declaration but without a body.

Measurement is shown in Fig.~\ref{fig:measure}. The statement \code{measure qubit|qreg -> bit|creg;} measures the qubit(s) in the $Z$-basis and records the measurement outcome(s) by overwriting the bit(s). Measurement corresponds to a projection onto one of the eigenstates of $Z$, and qubit(s) are immediately available for further quantum computation. Both arguments must be register-type, or both must be bit-type. If both arguments are register-type and have the same size, the statement \code{measure a -> b;} means apply \code{measure a[j] -> b[j];} for each index \code{j} into register \code{a}.

The \code{reset qubit|qreg;} statement resets a qubit or quantum register to the state $|0\rangle$. This corresponds to a partial trace over those qubits (i.e. discarding them) before replacing them with $|0\rangle\langle 0|$, as shown in Fig.~\ref{fig:prepare}.

\begin{figure}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c1}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c2}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c3}
\end{minipage}

\begin{minipage}{.3\textwidth}
\centering\include{qpics/c4}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c5}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c6}
\end{minipage}
\caption{The \code{measure} statement projectively measures a qubit or each qubit of a quantum register. The measurement projects onto the $Z$-basis and leaves qubits available for further operations. The top row of circuits depicts single-qubit measurement using the statement \code{measure q[0] -> c[0];} while the bottom depicts measurement of an entire register using the statement \code{measure q -> c;}. The center circuit of the top row depicts measurement as the final operation on \code{q[0]}.
\label{fig:measure}}
\end{figure}

\begin{figure}
\begin{minipage}{.3\textwidth}
\centering
\include{qpics/c7}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c8}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c9}
\end{minipage}
\caption{The \code{reset} statement prepares a qubit or quantum register in the state $|0\rangle$.
\label{fig:prepare}}
\end{figure}

There is one type of classically-controlled quantum operation: the \code{if} statement shown in Fig.~\ref{fig:if}. The \code{if} statement conditionally executes a quantum operation based on the value of a classical register. This allows measurement outcomes to determine future quantum operations. We choose to have one decision register for simplicity. This register is interpreted as an integer, using the bit at index zero as the low order bit. The quantum operation executes only if the register has the given integer value. Only quantum operations, i.e.\ built-in gates, gate (and opaque) subroutines, preparation, and measurement, can be prefaced by \code{if}. A quantum program with a parameter that depends on values that are known only at run-time can be rewritten using a sequence of \code{if} statements. Specifically, for a single-parameter gate with $n$ bits of precision, we may choose to write $2^n$ statements, only one of which is executed, or we can decompose the parameterized gate into a sequence of $n$ conditional gates.

\begin{figure}
\centering
\begin{minipage}{.3\textwidth}
\centering
\include{qpics/c10}
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering\include{qpics/c11}
\end{minipage}
\caption{The \code{if} statement applies a quantum operation only if a classical register has the indicated integer value. These circuits depict the statement \code{if(c==3) U(theta,phi,lambda) q[0];}.
\label{fig:if}}
\end{figure}

The \code{barrier} instruction prevents optimizations from reordering gates across its source line. For example,
\begin{minted}{c}
CX r[0],r[1]; 
h q[0]; 
h s[0];
barrier r,q[0];
h s[0]; 
CX r[1],r[0]; 
CX r[0],r[1];
\end{minted}
will prevent an attempt to combine the CNOT gates but will allow the pair of \code{h s[0];} gates to cancel.

Open QASM statements are summarized in Table~\ref{tab:qasm:new}. The grammar is presented in Appendix~\ref{app:grammar}.

\begin{landscape}
\begin{table}[htbp]
\begin{threeparttable}
\caption{Open QASM language statements (version 2.0)\label{tab:qasm:new}}
\begin{tabular}{@{}lll@{}}
\toprule
Statement & Description & Example \\
\midrule
\code{OPENQASM 2.0;} & Denotes a file in Open QASM format\tnote{a} & \code{OPENQASM 2.0;}\\
\code{qreg name[size];} & Declare a named register of qubits & \code{qreg q[5];} \\
\code{creg name[size];} & Declare a named register of bits & \code{creg c[5];} \\
\code{include "filename";} & Open and parse another source file & \code{include "qelib1.inc";} \\ 
\code{gate name(params) qargs \string{ body \string}} & Declare a unitary gate &  (see text) \\
\code{opaque name(params) qargs;} & Declare an opaque gate & (see text) \\
\code{// comment text} & Comment a line of text & \code{// oops!} \\
\midrule
\code{U(theta,phi,lambda) qubit|qreg;} & Apply built-in single qubit gate(s)\tnote{b} & \code{U(pi/2,2*pi/3,0) q[0];} \\
\code{CX qubit|qreg,qubit|qreg;} & Apply built-in CNOT gate(s) & \code{CX q[0],q[1];} \\
\code{measure qubit|qreg -> bit|creg;} & Make measurement(s) in $Z$ basis & \code{measure q -> c;} \\
\code{reset qubit|qreg;} & Prepare qubit(s) in $|0\rangle$ & \code{reset q[0];} \\ 
\code{gatename(params) qargs;} & Apply a user-defined unitary gate &  \code{crz(pi/2) q[1],q[0];} \\
\code{if(creg==int) qop;} & Conditionally apply quantum operation & \code{if(c==5) CX q[0],q[1];} \\ 
\midrule
\code{barrier qargs;} & Prevent transformations across this source line & \code{barrier q[0],q[1];} \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\item[a] This must appear as the first non-comment line of the file.
\item[b] The parameters \code{theta}, \code{phi}, and \code{lambda} are given by {\em parameter expressions}; see text and Appendix~\ref{app:grammar}.
\end{tablenotes}
\end{threeparttable}
\end{table}
\end{landscape}
\section{Examples}

This section gives several examples of quantum circuits expressed in Open QASM (version 2.0). The circuits use a gate basis defined for the Quantum Experience.

\subsection{Quantum Experience standard header}

The Quantum Experience standard header defines the gates that are implemented by the hardware, gates that appear in the Quantum Experience composer, and a hierarchy of additional user-defined gates. Our approach is to define physical gates that the hardware implements in terms of the abstract gates \code{U} and \code{CX}. The current physical gates supported by the Quantum Experience are a superset of the abstract gates, but this is not true of all physical gate sets and devices. Choosing to use abstract gates merely to define physical gates gives some flexibility to add or change physical gates at a later time without changing Open QASM. We believe this approach is preferable to invisibly compiling abstract gates to physical gates or to changing the underlying set of abstract gates whenever the hardware changes.

The Quantum Experience currently implements the controlled-NOT gate via the cross-resonance interaction and implements three distinct types of single-qubit gates. The one-parameter gate
\begin{equation}
u_1(\lambda) := \mathrm{diag}(1,e^{i\lambda}) \sim U(0,0,\lambda) = R_z(\lambda)
\end{equation}
changes the phase of a carrier without applying any pulses. The symbol ``$\sim$'' denotes equivalence up to a global phase. The gate
\begin{equation}
u_2(\phi,\lambda) := U(\pi/2,\phi,\lambda) = R_z(\phi+\frac{\pi}{2})R_x(\pi/2)R_z(\lambda-\frac{\pi}{2})
\end{equation}
uses a single $\pi/2$-pulse. The most general single-qubit gate
\begin{equation}
u_3(\theta,\phi,\lambda) := U(\theta,\phi,\lambda) = R_z(\phi+3\pi)R_x(\pi/2)R_z(\theta+\pi)R_x(\pi/2)R_z(\lambda)
\end{equation}
uses a pair of $\pi/2$-pulses.

\cfile{../examples/generic/qelib1.inc}

\subsection{Quantum teleportation}

Quantum teleportation (Fig.~\ref{fig:example:teleport}) demonstrates conditional application of future gates based on prior measurement outcomes.

\begin{figure}
\centering
\include{qpics/c12}
\caption{Example of quantum teleportation. Qubit \code{q[0]} is prepared by \code{U(0.3,0.2,0.1) q[0];} and teleported to \code{q[2]}.
\label{fig:example:teleport}}
\end{figure}
\cfile{../examples/generic/teleport.qasm}

\subsection{Quantum Fourier transform}
The quantum Fourier transform (QFT, Fig.~\ref{fig:example:qft}) demonstrates parameter passing to gate subroutines. This circuit applies the QFT to the state $|q_0 q_1 q_2 q_3\rangle=|1010\rangle$ and measures in the computational basis.

\begin{figure}
\centering
\include{qpics/c13}
\caption{Example of a $4$-qubit quantum Fourier transform. The circuit applies the QFT to $|1010\rangle$ and measures in the computational basis. The output is read in reverse order \code{c[3], c[2], c[1], c[0]}. \label{fig:example:qft}}
\end{figure}
\cfile{../examples/generic/qft.qasm}

\subsection{Inverse QFT followed by measurement}

If the qubits are all measured after the inverse QFT, the measurement commutes with the controls of the \code{cu1} gates, and those gates can be replaced by classically-controlled single qubit rotations (see for example Figure 3.3 in \cite{mermin}). The example demonstrates how to implement this classical control using conditional gates.

\begin{figure}
\hspace{-0.8cm}
\begin{minipage}{.8\textwidth}
\include{qpics/c13a}
\end{minipage}
\caption{Example of a $4$-qubit inverse quantum Fourier transform followed by measurement. In this case, the measurement commutes with the controls of the \code{cu1} gates and can be rewritten as shown (see Figure 3.3 in \cite{mermin}). The circuit applies the inverse QFT to the uniform superposition and measures in the computational basis. 
\label{fig:example:iqft}}
\end{figure}
\cfile{../examples/generic/inverseqft1.qasm}

Alternatively, we can decompose the rotations and apply them using fewer statements but more quantum gates. The corresponding circuit for this example is shown in Fig.~\ref{fig:example:iqft}.
\cfile{../examples/generic/inverseqft2.qasm}

\subsection{Ripple-carry adder}

The ripple-carry adder \cite{cuccaro04} shown in Fig.~\ref{fig:example:add} exhibits hierarchical use of gate subroutines.

\begin{figure}
\centering
\include{qpics/c14}
\caption{Example of a quantum ripple-carry adder from \cite{cuccaro04}. This circuit prepares $a=1$, $b=15$ and computes the sum into \code{b} with an output carry \code{cout[0]}.\label{fig:example:add}}
\end{figure}
\cfile{../examples/generic/adder.qasm}

\subsection{Randomized benchmarking}

A complete randomized benchmarking experiment could be described by a high level program. After passing through the upper phases of compilation, the program consists of many quantum circuits and associated classical control. Benchmarking is a particularly simple example because there is no data dependence between these quantum circuits. 

Each circuit is a sequence of random Clifford gates composed from a set of basic gates (Fig.~\ref{fig:example:rb} uses the gate set \code{h}, \code{s}, \code{cz}, and Paulis). If the gate set differs from the built-in gate set, new gates can be defined using the \code{gate} statement. Each of the randomly-chosen Clifford gates is separated from prior and future gates by barrier instructions to prevent the sequence from simplifying to the identity as a result of subsequent transformations.

\begin{figure}
\centering
\include{qpics/c15}
\caption{Example of a two-qubit randomized benchmarking (RB) sequence over the basis $\langle H, S, CZ, X, Y, Z\rangle$. Barriers separate the implementations of each Clifford gate. An RB experiment consists of many sequences. Each sequence runs some number of times (``shots'').\label{fig:example:rb}}
\end{figure}
\cfile{../examples/generic/rb.qasm}

\subsection{Quantum process tomography}

As in randomized benchmarking, a high-level program describes a quantum process tomography (QPT) experiment. Each program compiles to intermediate code with several independent quantum circuits that can each be described using Open QASM (version 2.0). Fig.~\ref{fig:example:qpt} shows QPT of a Hadamard gate. Each circuit is identical except for the definitions of the \code{pre} and \code{post} gates. The empty definitions in the current example are placeholders that define identity gates. For textbook QPT, the \code{pre} and \code{post} gates are both taken from the set $\{I,H,SH\}$ to prepare $|0\rangle$, $|+\rangle$, and $|+i\rangle$ and measure in the $Z$, $X$, and $Y$ basis.

\begin{figure}
\centering
\include{qpics/c16}
\caption{Example of a single-qubit quantum process tomography circuit. The \code{pre} and \code{post} gates are described by a higher-level program that generates intermediate code containing several independent circuits. Each circuit is executed some number of times (``shots'') to compute statistics from which the \code{h} gate process is reconstructed. Barriers separate the process under study from the pre- and post- gates. \label{fig:example:qpt}}
\end{figure}
\cfile{../examples/generic/qpt.qasm}

\subsection{Quantum error-correction}

This example of the 3-bit quantum repetition code (Fig.~\ref{fig:example:qec3}) demonstrates how Open QASM (version 2.0) can express simple quantum error-correction circuits.

\begin{figure}
\centering
\include{qpics/c17}
\caption{Example of a quantum bit-flip repetition code. The circuit begins with the (classical) encoded state $|000\rangle$, applies an error on \code{q[0]}, and uses feedback on a syndrome measurement to correct the error.
\label{fig:example:qec3}}
\end{figure}
\cfile{../examples/generic/qec.qasm}

\section{Acknowledgements}

This document represents ideas and contributions from the IBM Quantum Computing group as a whole. We acknowledge suggestions and discussions with the IBM Quantum Experience community \cite{qe}. We thank Abigail Cross for typesetting the figures and proof-reading the document. We thank Tom Draper and Sandy Kutin for the $\langle\mathrm{q}|\mathrm{pic}\rangle$ package \cite{qpic}, which was used for initial typesetting of the quantum circuits. We acknowledge partial support from the IBM Research Frontiers Institute.

\appendix

\section{Open QASM Grammar}\label{app:grammar}

\begin{bnf*}
\bnfprod{mainprogram}
{\begin{bnfsplit}\bnfts{OPENQASM} \bnfsp \bnfpn{real} \bnfsp \bnfts{;} \bnfsp \bnfpn{program}
\end{bnfsplit}
}\\
\bnfprod{program}
{\begin{bnfsplit}
\bnfpn{statement}
\bnfor \bnfpn{program} \bnfsp \bnfpn{statement}
\end{bnfsplit}
}\\
\bnfprod{statement}
{\begin{bnfsplit}\bnfpn{decl} \\
\bnfor \bnfpn{gatedecl} \bnfsp \bnfpn{goplist} \bnfsp \bnfts{\}} \\
\bnfor \bnfpn{gatedecl} \bnfsp \bnfts{\}} \\ 
\bnfor \bnfts{opaque} \bnfsp \bnfpn{id} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{;} \\
\bnfor \bnfts{opaque} \bnfsp \bnfpn{id} \bnfsp \bnfts{(} \bnfsp \bnfts{)} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{;}
\bnfor \bnfts{opaque} \bnfsp \bnfpn{id} \bnfsp \bnfts{(} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{)} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{;} \\
\bnfor \bnfpn{qop} \\
\bnfor \bnfts{if} \bnfsp \bnfts{(} \bnfsp \bnfpn{id} \bnfsp \bnfts{==} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{)} \bnfsp \bnfpn{qop} \\
\bnfor \bnfts{barrier} \bnfsp \bnfpn{anylist} \bnfsp \bnfts{;}
\end{bnfsplit}
}\\
\bnfprod{decl}
{\begin{bnfsplit}\bnfts{qreg} \bnfsp \bnfpn{id} \bnfsp \bnfts{[} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{]} \bnfsp \bnfts{;}
\bnfor \bnfts{creg} \bnfsp \bnfpn{id} \bnfsp \bnfts{[} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{]} \bnfsp \bnfts{;}
\end{bnfsplit}
}\\
\bnfprod{gatedecl}
{\begin{bnfsplit}\bnfts{gate} \bnfsp \bnfpn{id} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{\{} \\
\bnfor \bnfts{gate} \bnfsp \bnfpn{id} \bnfsp \bnfts{(} \bnfsp \bnfts{)} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{\{} \\
\bnfor \bnfts{gate} \bnfsp \bnfpn{id} \bnfsp \bnfts{(} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{)} \bnfpn{idlist} \bnfsp \bnfts{\{}
\end{bnfsplit}
}\\
\bnfprod{goplist}
{\begin{bnfsplit}\bnfpn{uop} \\
\bnfor \bnfts{barrier} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{;} \\
\bnfor \bnfpn{goplist} \bnfsp \bnfpn{uop} \\
\bnfor \bnfpn{goplist} \bnfsp \bnfts{barrier} \bnfsp \bnfpn{idlist} \bnfsp \bnfts{;}
\end{bnfsplit}
}\\
\bnfprod{qop}
{\begin{bnfsplit}\bnfpn{uop} \\
\bnfor \bnfts{measure} \bnfsp \bnfpn{argument} \bnfsp \bnfts{-} \bnfsp \bnfts{>} \bnfsp \bnfpn{argument} \bnfsp \bnfts{;} \\
\bnfor \bnfts{reset} \bnfsp \bnfpn{argument} \bnfsp \bnfts{;}
\end{bnfsplit}
}\\
\bnfprod{uop}
{\begin{bnfsplit}\bnfts{U} \bnfsp \bnfts{(} \bnfsp \bnfpn{explist} \bnfsp \bnfts{)} \bnfsp \bnfpn{argument} \bnfsp \bnfts{;} \\
\bnfor \bnfts{CX} \bnfsp \bnfpn{argument} \bnfsp \bnfts{,} \bnfsp \bnfpn{argument} \bnfsp \bnfts{;} \\
\bnfor \bnfpn{id} \bnfsp \bnfpn{anylist} \bnfsp \bnfts{;}
\bnfor \bnfpn{id} \bnfsp \bnfts{(} \bnfsp \bnfts{)} \bnfsp \bnfpn{anylist} \bnfsp \bnfts{;} \\
\bnfor \bnfpn{id} \bnfsp \bnfts{(} \bnfsp \bnfpn{explist} \bnfsp \bnfts{)} \bnfsp \bnfpn{anylist} \bnfsp \bnfts{;}
\end{bnfsplit}
}\\
\bnfprod{anylist}
{\begin{bnfsplit}\bnfpn{idlist}
\bnfor \bnfpn{mixedlist}
\end{bnfsplit}
}\\
\bnfprod{idlist}
{\begin{bnfsplit}\bnfpn{id}
\bnfor \bnfpn{idlist} \bnfsp \bnfts{,} \bnfsp \bnfpn{id}
\end{bnfsplit}
}\\
\bnfprod{mixedlist}
{\begin{bnfsplit}\bnfpn{id} \bnfsp \bnfts{[} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{]}
\bnfor \bnfpn{mixedlist} \bnfsp \bnfts{,} \bnfsp \bnfpn{id} \\
\bnfor \bnfpn{mixedlist} \bnfsp \bnfts{,} \bnfsp \bnfpn{id} \bnfsp \bnfts{[} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{]} \\
\bnfor \bnfpn{idlist} \bnfsp \bnfts{,} \bnfsp \bnfpn{id} \bnfts{[} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{]} \\
\end{bnfsplit}
}\\
\bnfprod{argument}
{\begin{bnfsplit}\bnfpn{id}
\bnfor \bnfpn{id} \bnfsp \bnfts{[} \bnfsp \bnfpn{nninteger} \bnfsp \bnfts{]}
\end{bnfsplit}
}\\
\bnfprod{explist}
{\begin{bnfsplit}\bnfpn{exp}
\bnfor \bnfpn{explist} \bnfsp \bnfts{,} \bnfsp \bnfpn{exp}
\end{bnfsplit}
}\\
\bnfprod{exp}
{\begin{bnfsplit} \bnfpn{real}
\bnfor \bnfpn{nninteger}
\bnfor \bnfts{pi}
\bnfor \bnfpn{id} \\
\bnfor \bnfpn{exp} \bnfsp \bnfts{+} \bnfsp \bnfpn{exp}
\bnfor \bnfpn{exp} \bnfsp \bnfts{-} \bnfsp \bnfpn{exp}
\bnfor \bnfpn{exp} \bnfsp \bnfts{*} \bnfsp \bnfpn{exp} \\
\bnfor \bnfpn{exp} \bnfsp \bnfts{/} \bnfsp \bnfpn{exp}
\bnfor \bnfts{-} \bnfsp \bnfpn{exp}
\bnfor \bnfpn{exp} \bnfsp \bnfts{\^} \bnfsp \bnfpn{exp} \\
\bnfor \bnfts{(} \bnfsp \bnfpn{exp} \bnfsp \bnfts{)}
\bnfor \bnfpn{unaryop} \bnfsp \bnfts{(} \bnfsp \bnfpn{exp} \bnfsp \bnfts{)} \\
\end{bnfsplit}
}\\
\bnfprod{unaryop}
{\begin{bnfsplit}\bnfts{sin}
\bnfor \bnfts{cos}
\bnfor \bnfts{tan}
\bnfor \bnfts{exp}
\bnfor \bnfts{ln}
\bnfor \bnfts{sqrt}
\end{bnfsplit}
}\\
\end{bnf*}

This is a simplified grammar for Open QASM presented in Backus-Naur form. The unlisted productions $\langle\mathrm{id}\rangle$, $\langle\mathrm{real}\rangle$ and $\langle\mathrm{nninteger}\rangle$ are defined by the regular expressions:
\begin{verbatim}
id        := [a-z][A-Za-z0-9_]*
real      := ([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([eE][-+]?[0-9]+)?
nninteger := [1-9]+[0-9]*|0
\end{verbatim}
Not all programs produced using this grammar are valid Open QASM circuits. As explained in Section~\ref{sec:spec}, there are additional rules concerning valid arguments, parameters, declarations, and identifiers, as well as the standard operator precedence rules in the parameter expressions.
             
\bibliographystyle{unsrt}
\bibliography{qasm2}

\end{document}
